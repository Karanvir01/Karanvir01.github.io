---
title: "Using the Minimax algorithm to build an unbeatable TicTacToe AI"
date: 2019-07-25
tags: [cool]
header:
  image: "/images/AI.jpeg"
excerpt: "Minimax, Java Coding, Artificial Intelligence, Game Trees"

---
# Creating an Unbeatable TicTacToe AI using the Minimax Algorithm

<img src="{{ site.url }}{{ site.baseurl }}/images/tic.png" alt="TicTacToe">

## Introduction

TicTacoToe is a very old game that was created in Ancient Egypt around 1300 BCE. Although initially used to test intelligence between individuals, it can be seen that if both players play in an optimal way the result is always a draw. Thus, using Artificial Intelligence, making a unbeatable computer is possible. Coding this has been quite enjoyable and I have learned much about game trees, recursive methods, and the Minimax Algorithm as well.

## Game Tree

A game tree is all the possibilities that a user can employ to make a move. By viewing multiple possibilities and layers of moves that can be made, an minimax algorithim can be created. For example, in TicTacToe, after a user moves, the computer will be given all the possible spots it can move and afterwards it will create another layer of the tree suggesting where the user could move. After doing that multiple times, the algorithm becomes unbeatable.

This is an image of a TicTacToe game tree:

<img src="{{ site.url }}{{ site.baseurl }}/images/game.jpg" alt="TicTacToe">

## Recursive methods

A recursive method is commonly used in java. The  definition of it is a method that repeatedly calls itself. For example, a common use of a recursive method is to solve a fibonacci series. This can be seen below:
 ```java
 public class FibonacciExample
 {
   public static int fibonacci(int x)
   {
    if(x<2)
      return x;
    else
      return fibonacci(x-1) + fibonacci(x-2);            
   }
 }
 ```
 Notice how that inside the fibonacci method, there is a call to itself in the return statement. This is what recursion is all about. The ability of a method to call itself. This becomes very helpful in the Minimax Algorithm as well.

## Minimax Algorithm

The Minimax algorithm is what allows us to create an unbeatable TicTacToe AI. To win a game of TicTacToe, one must be able to foresee multiple events and make a decision based on those future outcomes. The Minimax Algorithm does just that. It foresees all possible outcomes and based on that it makes its decision, which means that the AI will be unbeatable. The Minimax algorithm employs a backtracking recursive method that allows it to see ahead and make a decision based on those future outcomes.

The Minimax Algorithm code in java:

```java
private static int miniMax (Board.State player, Board board, int currentPly) {
        if (currentPly++ == maxPly || board.isGameOver()) {
            return score(player, board);
        }

        if (board.getTurn() == player) {
            return getMax(player, board, currentPly);
        } else {
            return getMin(player, board, currentPly);
        }

    }
    private static int getMax (Board.State player, Board board, int currentPly) {
        double bestScore = Double.NEGATIVE_INFINITY;
        int indexOfBestMove = -1;

        for (Integer theMove : board.getAvailableMoves()) {

            Board modifiedBoard = board.getDeepCopy();
            modifiedBoard.move(theMove);

            int score = miniMax(player, modifiedBoard, currentPly);

            if (score >= bestScore) {
                bestScore = score;
                indexOfBestMove = theMove;
            }

        }

        board.move(indexOfBestMove);
        return (int)bestScore;
    }

    /**
     * Play the move with the lowest score.
     * @param player        the player that the AI will identify as
     * @param board         the Tic Tac Toe board to play on
     * @param currentPly    the current depth
     * @return              the score of the board
     */
    private static int getMin (Board.State player, Board board, int currentPly) {
        double bestScore = Double.POSITIVE_INFINITY;
        int indexOfBestMove = -1;

        for (Integer theMove : board.getAvailableMoves()) {

            Board modifiedBoard = board.getDeepCopy();
            modifiedBoard.move(theMove);

            int score = miniMax(player, modifiedBoard, currentPly);

            if (score <= bestScore) {
                bestScore = score;
                indexOfBestMove = theMove;
            }

        }
      }
```
